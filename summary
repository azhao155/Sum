Topology sort:
  BFS: degree and neighbour, once degree equal 0, add into result
  	test distance
  DFS:
      visited[i] = 0. Exist. Non-visited.
      visited[i] = 1. Visiting.
      visited[i] = 2. Visited.
      
public boolean dfs(boolean[][] adj, int[] visited, StringBuilder sb, int i) {
    visited[i] = 1;                            // 1 = visiting
    for(int j = 0; j < N; j++) {
        if(adj[i][j]) {                        // connected
            if(visited[j] == 1) return false;  // 1 => 1, cycle   
            if(visited[j] == 0) {              // 0 = unvisited
                if(!dfs(adj, visited, sb, j)) return false;
            }
        }
    }
    visited[i] = 2;                           // 2 = visited
    sb.append((char) (i + 'a'));
    return true;
}


continous array:
    presum + hashmap
    
 
Array :   
	Hash 作为记忆的方法: 2sum 
	partition：
public int partition(int[] A){
    int n=A.length;
    int q=-1;
    for(int i=0;i<n;i++){
        if(A[i]>0){
            q++;
            swap(A,q,i);
        }
    }
    return q;
}

标记方法就是对正数加一个负号


Design data structure: 
1.	LRU: 
Get: remove, then add
Put remove, add , remove
Hash for quick look up, list for quick remove, insert

2.	用stack记录最近的local maximum

Link List:
	Reverse link list and check none 
	Two pointer, same as array
	Sort array sum, using two pointer
	3sum, two pointer for the sum
	Two pointer, 先走右边，走到符合规定，再动左边去violate
	first move to child, put child back in main thread



Graph:
	Mark visited, and dfs
	Union Find: 
        UnionFind(char[][] grid) {  
            m = grid.length;  
            n = grid[0].length;  
            father = new int[m*n];  
            for (int i = 0; i < m; i++) {  
                for (int j = 0; j < n; j++) {  
                    if (grid[i][j] == '1') {
                        int id = i * n + j;
                        father[id] = id;
                        count++;
                    }
                }  
            }  
        }
        public void union(int node1, int node2) {  
            int find1 = find(node1);
            int find2 = find(node2);
            if(find1 != find2) {
                father[find1] = find2;
                count--;
            }
        }
        public int find (int node) {  
            if (father[node] == node) {  
                return node;
            }
            father[node] = find(father[node]);  
            return father[node];
        }
    }
Use rank to check cycle


Palindrome :
	Dp  substring 顺序
	  for (int i = n - 1; i >= 0; i--) {
    for (int j = i; j < n; j++) {
      dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);
      
how to check two strings together is palindrome:
Case1: If s1 is a blank string, then for any string that is palindrome s2, s1+s2 and s2+s1 are palindrome.

Case 2: If s2 is the reversing string of s1, then s1+s2 and s2+s1 are palindrome.

Case 3: If s1[0:cut] is palindrome and there exists s2 is the reversing string of s1[cut+1:] , then s2+s1 is palindrome.

Case 4: Similiar to case3. If s1[cut+1: ] is palindrome and there exists s2 is the reversing string of s1[0:cut] , then s1+s2 is palindrome.
 
Binary Search:
	要去掉连续的一段

DP: 
	考虑最后一步，往往是包含这个元素


PriorityQueue：
	保持局部有序，只在乎極緻
	two prorioty queue, both needs to enter

Array:
	Sort by …
	Merge interval, sort by start, check new start and old end
	get start array and end array, two pointer 
	Hashmap to record presum

Bit operation:
	高位bit作为下一次的status

数字表示：
	Less than 20
	Tens
	Thousands

Tree:
	Serilize/deserilize, preorder and BFS
	travser while update global variable, thus updating all the variables
	
	
Parentheses:
	left_removed, right_removed, pair(dangling left Parentheses)
	dfs, open, close
	
Test justification:
 	try to add the current work, wordlist, accuLen

Next permutation:
	reverse sort, find a little bit larger, reverse again.
	
nested string:
	stack, cur_string, cur_num
	
dp: 
	outside layer to use the coin to avoid duplication
	
bucket:
	clock structure, only limited values	

regex match:
            if (p.charAt(j) == '.') {
                dp[i+1][j+1] = dp[i][j];
            }
            if (p.charAt(j) == s.charAt(i)) {
                dp[i+1][j+1] = dp[i][j];
            }
            if (p.charAt(j) == '*') {
                if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {
                    dp[i+1][j+1] = dp[i+1][j-1];
                } else {
                    dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);
                }
            }
