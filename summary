Topology sort:
  BFS: degree and neighbour, once degree equal 0, add into result
  DFS:
      visited[i] = 0. Exist. Non-visited.
      visited[i] = 1. Visiting.
      visited[i] = 2. Visited.
      
public boolean dfs(boolean[][] adj, int[] visited, StringBuilder sb, int i) {
    visited[i] = 1;                            // 1 = visiting
    for(int j = 0; j < N; j++) {
        if(adj[i][j]) {                        // connected
            if(visited[j] == 1) return false;  // 1 => 1, cycle   
            if(visited[j] == 0) {              // 0 = unvisited
                if(!dfs(adj, visited, sb, j)) return false;
            }
        }
    }
    visited[i] = 2;                           // 2 = visited
    sb.append((char) (i + 'a'));
    return true;
}


continous array:
    presum + hashmap
    
 
Array :   
1.	Hash 作为记忆的方法: 2sum 




Design data structure: 
1.	LRU: 
Get: remove, then add
Put remove, add , remove
Hash for quick look up, list for quick remove, insert

2.	用stack记录最近的local maximum

Link List:
	Reverse link list and check none 
	Two pointer, same as array
	Sort array sum, using two pointer
	3sum, two pointer for the sum
	Two pointer, 先走右边，走到符合规定，再动左边去violate



Graph:
	Mark visited, and dfs
	Union Find: 
        UnionFind(char[][] grid) {  
            m = grid.length;  
            n = grid[0].length;  
            father = new int[m*n];  
            for (int i = 0; i < m; i++) {  
                for (int j = 0; j < n; j++) {  
                    if (grid[i][j] == '1') {
                        int id = i * n + j;
                        father[id] = id;
                        count++;
                    }
                }  
            }  
        }
        public void union(int node1, int node2) {  
            int find1 = find(node1);
            int find2 = find(node2);
            if(find1 != find2) {
                father[find1] = find2;
                count--;
            }
        }
        public int find (int node) {  
            if (father[node] == node) {  
                return node;
            }
            father[node] = find(father[node]);  
            return father[node];
        }
    }
Use rank to check cycle


Palindrome :
	Dp  substring 顺序
	  for (int i = n - 1; i >= 0; i--) {
    for (int j = i; j < n; j++) {
      dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);
 
Binary Search:
	要去掉连续的一段

DP: 
	考虑最后一步，往往是包含这个元素


PriorityQueue：
	保持局部有序，只在乎極緻

Array:
	Sort by …
	Merge interval, sort by start, check new start and old end
	get start array and end array, two pointer 
	Hashmap to record presum

Bit operation:
	高位bit作为下一次的status

数字表示：
	Less than 20
	Tens
	Thousands

Tree:
	Serilize/deserilize, preorder and BFS
	
	
Parentheses:
	left_removed, right_removed, pair(dangling left Parentheses)
	dfs, open, close
	

